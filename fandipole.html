<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>VK3CPU Fan-Dipole Antenna Calculator</title>
        <link rel="stylesheet" href="magloop.css">
    </head>
    <body>
        <header>Miguel <a href="mailto:vk3cpu@gmail.com">VK3CPU</a> - Fan-Dipole Antenna Calculator 0.1</header>
        <section class="gridLayoutClass">
            <div class="chart-container" style="position: relative;">
                <canvas id="chartCanvas" class="chartCanvasClass">
                    2D Chart Canvas
                </canvas>
            </div>
            <div class="slider_container">
                <div class="sliders">
                    <label for="angle_slider">&#952:</label>
                    <input type="range" id="angle_slider" min="60" max="120" value="90" step="0.5">
                </div>
                <div class="sliders">
                    <label for="length1_slider">D1:</label>
                    <input type="range" id="length1_slider" min="0.0" max="21.0" value="20.0" step="0.05">
                </div>
                <div class="sliders">
                    <label for="length2_slider">D2:</label>
                    <input type="range" id="length2_slider" min="0.0" max="21.0" value="10.0" step="0.05">
                </div>
                <div class="sliders">
                    <label for="length3_slider">D3:</label>
                    <input type="range" id="length3_slider" min="0.0" max="21.0" value="5.0" step="0.05">
                </div>
                <div class="sliders">
                    <label for="length4_slider">D4:</label>
                    <input type="range" id="length4_slider" min="0.0" max="21.0" value="2.5" step="0.05">
                </div>
                <div class="sliders">
                    <label for="length5_slider">D5:</label>
                    <input type="range" id="length5_slider" min="0.0" max="21.0" value="1.25" step="0.025">
                </div>
            </div>
            <div id="antenna-front-container" class="antennaFront-container" style="position: relative;">
                <canvas id="antennaFront2D" class="antennaFrontClass" width="150" height="150">
                </canvas>    
            </div>
            <div id="antenna-side-container" class="antennaSide-container" style="position: relative;">
                <canvas id="antennaSide2D" class="antennaSideClass" width="150" height="150">
                </canvas>
            </div>
            <div class="notes">
            <b><u>Notes:</u></b><br>
            The Fan-Dipole Antenna Calculator was developed to predict the characteristics of a fan-dipole antenna with 
            5-elements, given physical dimensions entered via slider widgets. <br>
            It supports:
            <ul>
                <li>Five dipoles</li>
                <li>Change of droop angle</li>
                <li>metric and imperial units</li>
            </ul>
            I developed this fan-dipole calculator to take advantage of the 
            touch-screens and high-speed of modern mobile phones, to allow users to get realtime feedback of the predicted
            behaviour of a fan-dipole antenna. <br>-- 73 de VK3CPU<br><br>
            <u><b>Inputs via the slider and radio widgets:</b></u>
            <ul> 
                <li>&#952 : Droop angle in degrees</li>
                <li>D1 : Length of half-dipole (measured from feedpoint to wire-end)</li>
                <li>D1 : Length of half-dipole (measured from feedpoint to wire-end)</li>
                <li>D1 : Length of half-dipole (measured from feedpoint to wire-end)</li>
                <li>D1 : Length of half-dipole (measured from feedpoint to wire-end)</li>
                <li>D1 : Length of half-dipole (measured from feedpoint to wire-end)</li>
            </ul>
            <u><b>Calculated parameters:</b></u>
            <ul>
                <li>|Z| : Feedpoint impedance in ohms.</li>
                <li>SWR : Standing wave ratio.</li>
            </ul>
            <u><b>Usage hints:</b></u>
                <li>Tap on legend items to disable or enable an output parameter. This can be used to declutter the chart.</li>
                <li>Tap on a chart 'dot' to display a tooltip containing calculated output parameters for that frequency or band.</li>
            <br>
            <u><b>Other VK3CPU calculators:</b>
                <ul>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/magloop.html">Magloop Antenna Calculator</a></li>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/toroid.html">RF Toroid Calculator</a></li>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/inductor_imp.html">RF Inductor Calculator</a></li>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/short_dipole.html">Coil-loaded Dipole Antenna Calculator</a></li>
                </ul>
            </u>
            <br>
            <b><u>References:</u></b><br>
            [1]: B. Balanis, A. Boswell and M. Perks, <b>"Loss Mechanisms in the Electrically Small Loop Antenna"</b> <i>, IEEE Antennas and Propagation Magazine, 56, 4, August 2014, pp. 143.</i> <br>
            <br>
            <b><u>Change history:</u></b><br>

            <b>[27-May-25]</b> <br>
            * Draft check-in.<br>
            <br>
            </div>
        </section>
        <script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.1/dist/chart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.5.1/math.min.js"></script>
        <script>
            // GUI control widgets:
            var angle_slider = document.getElementById("angle_slider");
            var length1_slider = document.getElementById("length1_slider");
            var length2_slider = document.getElementById("length2_slider");
            var length3_slider = document.getElementById("length3_slider");
            var length4_slider = document.getElementById("length4_slider");
            var length5_slider = document.getElementById("length5_slider");
            
            const params_to_sliders = {
              angle: angle_slider,
              length1: length1_slider,
              length2: length2_slider,
              length3: length3_slider,
              length4: length4_slider,
              length5: length5_slider,
            }
            const sliders_to_params = Object.entries(params_to_sliders).map(([k, v]) => [v, k]);

            // If there's a query param in the URL, set each slider's value to the respective params.
            for (const [key, value] of new URLSearchParams(window.location.search)) {
              var slider = params_to_sliders[key];
              if (slider) {
                slider.value = value;
              }
            }
            
            // Function to call after a successful recalculation
            const updateURL = function() {
              const usp = new URLSearchParams();
              for (const [slider, param] of sliders_to_params) {
                if (slider == null) continue;
                var value = slider.value;
                usp.set(param, value);
              }

              var new_url = new URL(window.location.href);
              new_url.search = usp;
              window.history.replaceState(null, null, new_url);
            }

            // Global variables:
            const mu0 = Math.PI * 4e-7;
            var droop_angle = 90.0;
            
            const GAMMA = 0.5772156649015329; // Euler-Mascheroni constant
            const C = 299792458.0;
            
            let detail_level = 1; // 0 for low
            var frequencies = [];
            var lengths = [];
            var impedances = [];
            var SWRs = [];

            function updateFrequencies() {
                frequencies = [];
                if(detail_level) {
                    for(var i=1; i<=3000; i++) {
                        frequencies.push(i * 0.01);
                    }
                } else {
                    for(var i=1; i<=150; i++) {
                        frequencies.push(i * 0.20);
                    }
                }
            }
            
            function setGlobals() {
                droop_angle = angle_slider.value;
                lengths = [];
                lengths.push(length1_slider.value);
                lengths.push(length2_slider.value);
                lengths.push(length3_slider.value);
                lengths.push(length4_slider.value);
                lengths.push(length5_slider.value);
            }
            
            // Standard Cosine Integral, Ci(x)
            function ci(x) {
                // Input validation: ensure x is a positive number
                if (typeof x !== 'number' || x <= 0 || isNaN(x)) {
                    throw new Error('Input x must be a positive number');
                }
            
                // Numerical integration parameters
                const n = 1000; // Number of trapezoids
                const h = x / n; // Step size
            
                // Integrand function: (cos(t) - 1) / t
                function integrand(t) {
                    // Handle t near 0: (cos(t) - 1)/t ≈ -t/2 for small t
                    if (Math.abs(t) < 1e-10) {
                        return -t / 2;
                    }
                    return (Math.cos(t) - 1) / t;
                }
            
                // Trapezoidal rule
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    const t = i * h;
                    if (i === 0 || i === n) {
                        sum += integrand(t) / 2; // Endpoints get half weight
                    } else {
                        sum += integrand(t);
                    }
                }
            
                // Compute Ci(x) = gamma + ln(x) + integral
                return GAMMA + Math.log(x) + sum * h;
            }
            
            // Standard Sine Integral, Si(x)
            function si(x) {
                // Input validation: ensure x is a non-negative number
                if (typeof x !== 'number' || x < 0 || isNaN(x)) {
                    throw new Error('Input x must be a non-negative number');
                }
            
                // Handle x = 0 case: Si(0) = 0
                if (x === 0) return 0;
            
                // Numerical integration parameters
                const n = 1000; // Number of trapezoids
                const h = x / n; // Step size
            
                // Integrand function: sin(t) / t
                function integrand(t) {
                    // Handle t near 0: sin(t)/t ≈ 1 for small t
                    if (Math.abs(t) < 1e-10) {
                        return 1;
                    }
                    return Math.sin(t) / t;
                }
            
                // Trapezoidal rule
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    const t = i * h;
                    if (i === 0 || i === n) {
                        sum += integrand(t) / 2; // Endpoints get half weight
                    } else {
                        sum += integrand(t);
                    }
                }
            
                return sum * h;
            }
            
            function cin(x) {
                // Input validation: ensure x is a positive number
                if (typeof x !== 'number' || x < 0 || isNaN(x)) {
                    throw new Error('Input x must be a non-negative number');
                }
            
                // Handle x = 0 case: Cin(0) = 0
                if (x === 0) return 0;
            
                // Numerical integration parameters
                const n = 1000; // Number of trapezoids (higher for more accuracy)
                const h = x / n; // Step size
            
                // Integrand function: (1 - cos(t)) / t
                function integrand(t) {
                    // Handle t near 0 to avoid division by zero
                    if (Math.abs(t) < 1e-10) {
                        // Use Taylor approximation: (1 - cos(t))/t ≈ t/2 for small t
                        return t / 2;
                    }
                    return (1 - Math.cos(t)) / t;
                }
            
                // Trapezoidal rule
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    const t = i * h;
                    if (i === 0 || i === n) {
                        // Endpoints get half weight in trapezoidal rule
                        sum += integrand(t) / 2;
                    } else {
                        sum += integrand(t);
                    }
                }
            
                // Multiply by step size to get integral
                return sum * h;
            }

            function radiationResistance(frequency, antenna_length) {
                const wavelength = 299792458.0 / frequency;
                const length_in_lambda = antenna_length / wavelength;
                const neta = 120.0 * Math.PI;
                const C = 0.5772;  // Eulers constant (see Balanis eq 4-68)
                let kl = 2.0 * Math.PI * length_in_lambda; // Check this!
                let Rr = 0.0;
                Rr += C + Math.log(kl);
                Rr -= ci(kl);
                Rr += 0.5 * Math.sin(kl) * (si(2*kl) - 2*si(kl));
                Rr += 0.5 * Math.cos(kl) * (C + Math.log(kl * 0.5) + ci(2 * kl) - 2 * ci(kl));
                Rr *= neta / (2 * Math.PI);
                return Rr;
            }

            function inductiveReactance(frequency, antenna_length) {
                const wavelength = 299792458.0 / frequency;
                const length_in_lambda = antenna_length / wavelength;
                const neta = 120.0 * Math.PI;
                const C = 0.5772;   // Eulers constant (see Balanis eq 4-68)
                const a = 0.001;    // wire radius in lambda
                let kl = 2.0 * Math.PI * length_in_lambda; // Check this!
                let retval = 0.0;
                retval += 2 * si(kl);
                retval += Math.cos(kl) * (2*si(kl) - si(2 * kl));
                retval -= Math.sin(kl) * (2*ci(kl) - ci(2*kl)- ci(4.0 * Math.PI * a**2.0 / length_in_lambda));
                retval *= neta / (4 * Math.PI);
                return retval;
            }

            function calculateAll() {
                impedances = [];
                SWRs = [];
                frequencies.forEach(freq => {
                    let total_admittance = math.complex(0,0);
                    lengths.forEach(len => {
                        const rr = radiationResistance(freq * 1e6, len);
                        const xx = inductiveReactance(freq * 1e6, len);
                        let impedance = math.complex(rr, xx);
                        let admittance = impedance.inverse();
                        total_admittance = math.add(total_admittance, admittance);
                    });
                    const impedance = total_admittance.inverse();
                    const impedance_polar = impedance.toPolar();
                    impedances.push({x:freq, y:impedance.re});
                    
                    // Now calculate gamma, then the SWR:
                    const Z0 = math.complex(50.0, 0.0);
                    const gamma = math.divide(math.subtract(impedance, Z0), math.add(impedance, Z0));
                    const SWR = (1 + gamma.toPolar().r)/(1 - gamma.toPolar().r);
                    SWRs.push({x:freq, y:SWR});
                });
            }   

            function calculateImpedance() {
                var retval = [];
                impedances.forEach(item => {
                    retval.push(item);
                })
                return retval;
            }

            function calculateSWR() {
                var retval = [];
                SWRs.forEach(item => {
                    retval.push(item);
                })
                return retval;
            }

            function updateAll() {
                setGlobals();
                drawFrontDesign();
                drawSideDesign();
                updateFrequencies();
                calculateAll();
                myChart.data.datasets[0].data = calculateImpedance();
                myChart.data.datasets[1].data = calculateSWR();
                myChart.update();
                updateURL();
            }

            // Specify fonts for changing parameters controlled by the sliders:
            const normal_font = "12px arial";
            const emphasis_font = "bold 14px arial";
            const emphasis_delay = 600;
            
            const normal_width = 1;
            const emphasis_width = 3;
            
            var angle_timer_handler = 0;
            var angle_font = normal_font;
            var angle_thickness = normal_width;
            angle_slider.oninput = function() {
                if(angle_timer_handler == 0) {
                    angle_font = emphasis_font;
                    angle_thickness = emphasis_width;
                } else {
                    clearTimeout(angle_timer_handler);
                }
                angle_timer_handler = setTimeout(function(){
                    angle_font = normal_font;
                    angle_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    angle_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length1_timer_handler = 0;
            var length1_font = normal_font;
            var length1_thickness = normal_width;
            length1_slider.oninput = function() {
                if(length1_timer_handler == 0) {
                    length1_font = emphasis_font;
                    length1_thickness = emphasis_width;
                } else {
                    clearTimeout(length1_timer_handler);
                }
                length1_timer_handler = setTimeout(function(){
                    length1_font = normal_font;
                    length1_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length1_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length2_timer_handler = 0;
            var length2_font = normal_font;
            var length2_thickness = normal_width;
            length2_slider.oninput = function() {
                if(length2_timer_handler == 0) {
                    length2_font = emphasis_font;
                    length2_thickness = emphasis_width;
                } else {
                    clearTimeout(length2_timer_handler);
                }
                length2_timer_handler = setTimeout(function(){
                    length2_font = normal_font;
                    length2_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length2_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length3_timer_handler = 0;
            var length3_font = normal_font;
            var length3_thickness = normal_width;
            length3_slider.oninput = function() {
                if(length3_timer_handler == 0) {
                    length3_font = emphasis_font;
                    length3_thickness = emphasis_width;
                } else {
                    clearTimeout(length3_timer_handler);
                }
                length3_timer_handler = setTimeout(function(){
                    length3_font = normal_font;
                    length3_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length3_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length4_timer_handler = 0;
            var length4_font = normal_font;
            var length4_thickness = normal_width;
            length4_slider.oninput = function() {
                if(length4_timer_handler == 0) {
                    length4_font = emphasis_font;
                    length4_thickness = emphasis_width;
                } else {
                    clearTimeout(length4_timer_handler);
                }
                length4_timer_handler = setTimeout(function(){
                    length4_font = normal_font;
                    length4_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length4_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length5_timer_handler = 0;
            var length5_font = normal_font;
            var length5_thickness = normal_width;
            length5_slider.oninput = function() {
                if(length5_timer_handler == 0) {
                    length5_font = emphasis_font;
                    length5_thickness = emphasis_width;
                } else {
                    clearTimeout(length5_timer_handler);
                }
                length5_timer_handler = setTimeout(function(){
                    length5_font = normal_font;
                    length5_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length5_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            window.onresize = function() {
                myChart.resize();
                //myChart.update();
                drawFrontDesign();
                drawSideDesign();
                // console.log("resize!");
            }

            window.onorientationchange = function() {
                //myChart.resize();
                //myChart.update();
                drawFrontDesign();
                drawSideDesign();
            }

            window.onbeforeprint = function() {
                console.log("onbeforeprint");
                //myChart.resize();
                drawFrontDesign();
                drawSideDesign();
            }

            const afront_canvas = document.getElementById("antennaFront2D");
            const fctx = afront_canvas.getContext('2d');

            function drawFrontDesign() {
                const win_width  = document.getElementById("antenna-front-container").offsetWidth; 
                const win_height = document.getElementById("antenna-front-container").offsetHeight; 
                afront_canvas.width = win_width-2; 
                afront_canvas.height = win_height-2; 

                fctx.clearRect(0, 0, win_width, win_height);
                
                fctx.font = angle_font;
                fctx.textAlign = "left";
                fctx.fillText(angle_slider.value + '\u00B0', 10, 15);
                fctx.font = normal_font;
            }
            
            const aside_canvas = document.getElementById("antennaSide2D");
            const sctx = aside_canvas.getContext('2d');

            function drawSideDesign() {
                const win_width  = document.getElementById("antenna-side-container").offsetWidth; 
                const win_height = document.getElementById("antenna-side-container").offsetHeight; 
                aside_canvas.width = win_width-2; 
                aside_canvas.height = win_height-2; 
                sctx.clearRect(0, 0, win_width, win_height);
                
                const xx = 70;
                sctx.textAlign = "right";
                sctx.font = length1_font;
                sctx.fillText((1.0 * length1_slider.value).toFixed(3) + ' m', xx, 30);
                sctx.font = length2_font;
                sctx.fillText((1.0 * length2_slider.value).toFixed(3) + ' m', xx, 45);
                sctx.font = length3_font;
                sctx.fillText((1.0 * length3_slider.value).toFixed(3) + ' m', xx, 60);
                sctx.font = length4_font;
                sctx.fillText((1.0 * length4_slider.value).toFixed(3) + ' m', xx, 75);
                sctx.font = length5_font;
                sctx.fillText((1.0 * length5_slider.value).toFixed(3) + ' m', xx, 90);
                sctx.font = normal_font;
            }
            
            // Set the global variables, which are all determined by physical dimensions, and are thus frequency-independent:
            setGlobals();
            // Update the frequencies, now that we have the sliders available:
            updateFrequencies();
            calculateAll();
            drawFrontDesign();
            drawSideDesign();

            const chartCanvas = document.getElementById("chartCanvas");
            const chartCanvasContext = chartCanvas.getContext('2d');

            function getMetricPrefix(num) {
                if(num >= 1e9) return  {val: num*1e-9, pfx:'G'};
                if(num >= 1e6) return  {val: num*1e-6, pfx:'M'};
                if(num >= 1e3) return  {val: num*1e-3, pfx:'k'};
                if(num < 1e-12) return {val: num*1e15, pfx:'f'};
                if(num < 1e-9) return  {val: num*1e12, pfx:'p'};
                if(num < 1e-6) return  {val: num*1e9,  pfx:'n'};
                if(num < 1e-3) return  {val: num*1e6,  pfx:'\u03bc'};
                if(num < 1.0) return   {val: num*1e3,  pfx:'m'};
                return {val:num, pfx:' '};
            }
            
            function justifyText(pre, post) {
                var whitespace = 22 - pre.length - post.length;
                if(whitespace < 0) { whitespace = 0;}
                return pre + ' '.repeat(whitespace) + post;
            }
            
            var myChart = new Chart(chartCanvasContext, {
                type: 'line',
                data: {
                    datasets: [
                    {
                        label: '|Z|',
                        fill: false,
                        borderColor: 'black',
                        backgroundColor: 'black',
                        data: calculateImpedance(),
                        borderWidth: 1,
                        yAxisID: 'ohmsID',
                        tension: 0.3,
                    },
                    {
                        label: 'SWR',
                        fill: false,
                        borderColor: 'blue',
                        backgroundColor: 'blue',
                        data: calculateSWR(),
                        borderWidth: 1,
                        yAxisID: 'swrID',
                        tension: 0.3,
                    }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    elements: {
                        point: {
                            radius: 0,
                        },
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            display: 'auto',
                            title: {
                                display: true,
                                text: 'Frequency (MHz)',
                                color: 'black',
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                autoSkip: false,
                            }
                        },
                        'ohmsID' : {
                            type: 'linear',
                            display: 'auto',
                            title: {
                                display: true,
                                text: '\u03A9',
                                color: 'black',
                                font: {
                                        weight : 'bold'
                                }
                            },
                            ticks: {
                                beginAtZero: true,
                            },
                            min: 0.0,
                            max: 100.0,
                            position: 'left',
                        },
                        'swrID' : {
                            type: 'linear',
                            display: 'auto',
                            title: {
                                display: true,
                                text: 'VSWR',
                                color: 'blue',
                                font: {
                                        weight : 'bold'
                                }
                            },
                            ticks: {
                                beginAtZero: true,
                            },
                            min: 1.0,
                            max: 10.0,
                            position: 'left',
                        },
                    },
                    plugins: {
                        //showLines: true,
                        mode: 'nearest',
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            position: 'nearest',
                            bodyFont: {
                                family: 'monospace',
                            },
                            callbacks: {
                                title: function(context) {
                                    var value = context[0].parsed.x;
                                    var lut = [
                                    [0.1357, 0.1378,'2200'], 
                                    [0.472, 0.479, '600'], 
                                    [1.8, 1.875, '160'], 
                                    [3.5, 3.8, '80'], 
                                    [5.3, 5.4, '60'], 
                                    [7.0, 7.3, '40'], 
                                    [10.1, 10.15, '30'], 
                                    [14.0, 14.35, '20'], 
                                    [18.068, 18.168, '17'], 
                                    [21.0, 21.45, '15'], 
                                    [24.89, 24.99, '12'], 
                                    [26.965, 27.855, '11'], 
                                    [28.0, 29.7, '10'], 
                                    [50.0, 54.0, '6']];
                                    var label = '' + value.toFixed(3).toString() + ' MHz';
                                    for(let i = 0; i < lut.length; i++) {
                                        if((value >= lut[i][0]) && (value <= lut[i][1])) {
                                            label += ' (';
                                            label += lut[i][2] + ' m)';
                                            break;
                                        }
                                    }
                                    return label;
                                },
                                label: function(context) {
                                    var value = context.element.parsed.y;
                                    var label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if(context.dataset.label == "Tuning Cap (pF)") { 
                                        var num = getMetricPrefix(value * 1e-12);
                                        label = justifyText("Tuning Cap: ", num.val.toPrecision(3).toString() + '  ' + num.pfx + 'F');
                                    } else 
                                    if(label[0] == "Q"){
                                        label = justifyText("Q: ", Math.round(value).toString() + "    ");
                                    } else 
                                    if(label[0] == 'V'){
                                        var num = getMetricPrefix(value * 1e3);
                                        label = justifyText("Vcap: ", num.val.toPrecision(3).toString() + '  ' + num.pfx + 'V');
                                    } else 
                                    if(label[0] == 'B'){
                                        var num = getMetricPrefix(value * 1e3);
                                        label = justifyText("Bandwidth: ", num.val.toPrecision(3).toString() + ' ' + num.pfx + 'Hz');
                                    } else 
                                    if(label[0] == 'E'){
                                        label = justifyText("Efficiency: ", value.toFixed(2).toString() + '  ' + ' %');
                                    } else 
                                    if((label[0] == 'R') && (label[2] == 'r')){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("R-rad: ", num.val.toPrecision(3).toString() + '  ' + num.pfx + '\u03A9');
                                    } else 
                                    if((label[0] == 'R') && (label[2] == 'l')){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("R-loop: ", num.val.toPrecision(3).toString() + '  ' + num.pfx + '\u03A9');
                                    } else 
                                    if((label[0] == 'R') && (label[1] == 'e')){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("Reactance: ", 'j' + num.val.toPrecision(3) + '  ' + num.pfx + '\u03A9');
                                    } else 
                                    if(label[0] == 'I'){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("I\u2092: ", num.val.toPrecision(3).toString() + '  ' + num.pfx + 'A');
                                    } else 
                                    if(label[1] == 'Z'){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("|Z|: ", num.val.toFixed(3).toString() + '   ' + num.pfx + '\u03A9');
                                    } else 
                                    if(label[0] == 'S'){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("SWR: ", num.val.toPrecision(3).toString() + '    ' + num.pfx);
                                    } else {
                                        label += value.toFixed(3).toString();
                                    }
                                    return label;
                                }
                            }
                        },
                    }
                }
            });
        </script>
    </body>
</html>
