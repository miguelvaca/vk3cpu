<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>VK3CPU Fan-Dipole Antenna Calculator</title>
        <link rel="stylesheet" href="fandipole.css">
    </head>
    <body>
        <header>Miguel <a href="mailto:vk3cpu@gmail.com">VK3CPU</a> - Fan-Dipole Antenna Calculator 0.3</header>
        <section class="gridLayoutClass">
            <div class="chart-container" style="position: relative;">
                <canvas id="chartCanvas" class="chartCanvasClass">
                    2D Chart Canvas
                </canvas>
            </div>
            <div class="slider_container">
                <div class="sliders">
                    <label for="angle_cb">&#952:</label>
                    <input type="checkbox" id="angle_cb" >
                    <input type="range" id="angle_slider" min="0" max="45" value="0" step="1">
                </div>
                <div class="sliders">
                    <label for="length1_cb">D1:</label>
                    <input type="checkbox" id="length1_cb" checked>
                    <input type="range" id="length1_slider" min="0.0" max="22.0" value="20.27" step="0.01">
                </div>
                <div class="sliders">
                    <label for="length2_cb">D2:</label>
                    <input type="checkbox" id="length2_cb" checked>
                    <input type="range" id="length2_slider" min="0.0" max="22.0" value="14.27" step="0.01">
                </div>
                <div class="sliders">
                    <label for="length3_cb">D3:</label>
                    <input type="checkbox" id="length3_cb" >
                    <input type="range" id="length3_slider" min="0.0" max="22.0" value="10.05" step="0.01">
                </div>
                <div class="sliders">
                    <label for="length4_slider">D4:</label>
                    <input type="checkbox" id="length4_cb" >
                    <input type="range" id="length4_slider" min="0.0" max="22.0" value="6.91" step="0.01">
                </div>
                <div class="sliders">
                    <label for="length5_slider">D5:</label>
                    <input type="checkbox" id="length5_cb" >
                    <input type="range" id="length5_slider" min="0.0" max="22.0" value="5.01" step="0.01">
                </div>
            </div>
            <div id="antenna-front-container" class="antennaFront-container" style="position: relative;">
                <canvas id="antennaFront2D" class="antennaFrontClass" width="150" height="150">
                </canvas>    
            </div>
            <div id="antenna-side-container" class="antennaSide-container" style="position: relative;">
                <canvas id="antennaSide2D" class="antennaSideClass" width="150" height="150">
                </canvas>
            </div>
            <div class="notes">
            <b><u>Notes:</u></b><br>
            The Fan-Dipole Antenna Calculator was developed to predict the characteristics of a fan-dipole antenna with 
            up-to 5-elements, given physical dimensions entered via slider widgets. It allows you to see what the effects
            of additional dipoles will do to the feedpoint impedance (and therefore the VSWR) for your antenna. <br>
            It supports:
            <ul>
                <li>Up-to Five dipole elements</li>
                <li>Change of droop angle (FUTURE)</li>
                <li>metric and imperial units</li>
            </ul>
            It is based on [1] closed-form equations (8-60a) and (8-60b), which solve for the feedpoint resistance (Rin) and inductance (Xin)
            of a center-fed wire antenna for a given frequency. These are then used to solve for the parallel impedance of the enabled elements.
            It assumes the wire-elements are uncoupled, so ensure you use spreaders to keep the elements well-separated.
            The intent is to use this tool to quickly select your dipole lengths. You could then use an electromagnetic solver 
            such as EZNEC or MMANA-GAL for more accurate modeling including environmental effects such as height-above-ground.
            I developed this fan-dipole calculator to take advantage of the 
            touch-screens and high-speed of modern mobile phones, to allow users to get realtime feedback of the predicted
            behaviour of a fan-dipole antenna. <br>-- 73 de VK3CPU<br><br>
            <u><b>Inputs via the slider and radio widgets:</b></u>
            <ul> 
                <li>&#952 : Droop angle in degrees [NOT YET IMPLEMENTED!]</li>
                <li>D1 : Length of dipole (end-to-end)</li>
                <li>D2 : Length of dipole (end-to-end)</li>
                <li>D3 : Length of dipole (end-to-end)</li>
                <li>D4 : Length of dipole (end-to-end)</li>
                <li>D5 : Length of dipole (end-to-end)</li>
            </ul>
            <u><b>Calculated parameters:</b></u>
            <ul>
                <li>VSWR : Voltage Standing Wave Ratio  [1 - 5]</li>
                <li>|Z|  : Feedpoint impedance in Ohms  [0 - 500]</li>
                <li>Rin  : Feedpoint resistance in Ohms [0 - 500]</li>
                <li>Xin  : Feedpoint inductance in Ohms [0 - 500]</li>
            </ul>
            <u><b>Usage hints:</b></u>
                <li>Tap on legend items to disable or enable an output parameter. This can be used to declutter the chart.</li>
                <li>Tap on a chart curve to display a tooltip containing calculated output parameters for that frequency.</li>
            <br>
            <u><b>TODO:</b></u>
                <li>Implement droop angle effects.</li>
                <li>Draw the droop angle schematic.</li>
                <li>Draw the dipole lengths schematic.</li>
                <li>Solve for the relative currents and therefore power per element.</li>
                <li>Save the checkbox state in the URL.</li>
            <br>
            <u><b>Other VK3CPU calculators:</b>
                <ul>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/magloop.html">Magloop Antenna Calculator</a></li>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/toroid.html">RF Toroid Calculator</a></li>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/inductor_imp.html">RF Inductor Calculator</a></li>
                    <li><a href="https://miguelvaca.github.io/vk3cpu/short_dipole.html">Coil-loaded Dipole Antenna Calculator</a></li>
                </ul>
            </u>
            <br>
            <b><u>References:</u></b><br>
            [1]: Constantine A. Balanis, <b>"Antenna Theory 3rd Ed"</b> <i>, Wiley, 2005, pp. 465.</i> <br>
            <br>
            <b><u>Change history:</u></b><br>

            <b>[27-May-25]</b> <br>
            * Draft check-in.<br>
            <br>
            </div>
        </section>
        <script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.1/dist/chart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.5.1/math.min.js"></script>
        <script>
            // Global variables:
            const mu0 = Math.PI * 4e-7;
            var droop_angle = 90.0;
            
            const GAMMA = 0.5772156649015329; // Euler-Mascheroni constant
            const CC = 299792458.0;
                        
            let detail_level = 1; // 0 for low
            var frequencies = [];
            var lengths = [];
            var feedpoint_impedances = [];
            var SWRs = [];
            
            var dipole = {};
            
            // GUI control widgets:
            var angle_slider = document.getElementById("angle_slider");
            var length1_slider = document.getElementById("length1_slider");
            var length2_slider = document.getElementById("length2_slider");
            var length3_slider = document.getElementById("length3_slider");
            var length4_slider = document.getElementById("length4_slider");
            var length5_slider = document.getElementById("length5_slider");
            
            const params_to_sliders = {
              angle: angle_slider,
              length1: length1_slider,
              length2: length2_slider,
              length3: length3_slider,
              length4: length4_slider,
              length5: length5_slider
            }
            const sliders_to_params = Object.entries(params_to_sliders).map(([k, v]) => [v, k]);


            // Get all widget sets
            const widgetSets = document.querySelectorAll('section div.sliders');
        
            // Add event listener to each checkbox
            widgetSets.forEach(set => {
              const checkbox = set.querySelector('input[type="checkbox"]');
              const range = set.querySelector('input[type="range"]');
        
              // Initialize range state based on checkbox
              range.disabled = !checkbox.checked;
        
              // Toggle range disabled state when checkbox changes
              checkbox.addEventListener('change', () => {
                range.disabled = !checkbox.checked;
                updateAll();
              });
            });


            // If there's a query param in the URL, set each slider's value to the respective params.
            for (const [key, value] of new URLSearchParams(window.location.search)) {
              var slider = params_to_sliders[key];
              if (slider) {
                slider.value = value;
              }
            }
            
            // Function to call after a successful recalculation
            const updateURL = function() {
              const usp = new URLSearchParams();
              for (const [slider, param] of sliders_to_params) {
                if (slider == null) continue;
                var value = slider.value;
                usp.set(param, value);
              }

              var new_url = new URL(window.location.href);
              new_url.search = usp;
              window.history.replaceState(null, null, new_url);
            }


            function updateFrequencies() {
                frequencies = [];
                if(detail_level) {
                    for(var i=100; i<=3000; i++) {
                        frequencies.push(i * 0.01);
                    }
                } else {
                    for(var i=10; i<=150; i++) {
                        frequencies.push(i * 0.20);
                    }
                }
            }
            
            function setGlobals() {
            
                dipole['D1'] = {'length':length1_slider.value, 'enabled':length1_cb.checked, 'Rr':[], 'Xm':[], 'Z':[] };
                dipole['D2'] = {'length':length2_slider.value, 'enabled':length2_cb.checked, 'Rr':[], 'Xm':[], 'Z':[] };
                dipole['D3'] = {'length':length3_slider.value, 'enabled':length3_cb.checked, 'Rr':[], 'Xm':[], 'Z':[] };
                dipole['D4'] = {'length':length4_slider.value, 'enabled':length4_cb.checked, 'Rr':[], 'Xm':[], 'Z':[] };
                dipole['D5'] = {'length':length5_slider.value, 'enabled':length5_cb.checked, 'Rr':[], 'Xm':[], 'Z':[] };
                
                droop_angle = angle_slider.value;
                
                feedpoint_impedances = [];
                SWRs = [];
            }
            
            // Standard Cosine Integral, Ci(x)
            function ci(x) {
                // Input validation: ensure x is a positive number
                if (typeof x !== 'number' || x <= 0 || isNaN(x)) {
                    throw new Error('Input x must be a positive number');
                }
            
                // Numerical integration parameters
                const n = 1000; // Number of trapezoids
                const h = x / n; // Step size
            
                // Integrand function: (cos(t) - 1) / t
                function integrand(t) {
                    // Handle t near 0: (cos(t) - 1)/t ≈ -t/2 for small t
                    if (Math.abs(t) < 1e-10) {
                        return -t / 2;
                    }
                    return (Math.cos(t) - 1) / t;
                }
            
                // Trapezoidal rule
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    const t = i * h;
                    if (i === 0 || i === n) {
                        sum += integrand(t) / 2; // Endpoints get half weight
                    } else {
                        sum += integrand(t);
                    }
                }
                // Compute Ci(x) = gamma + ln(x) + integral
                return GAMMA + Math.log(x) + sum * h;
            }
            
            // Standard Sine Integral, Si(x)
            function si(x) {
                // Input validation: ensure x is a non-negative number
                if (typeof x !== 'number' || x < 0 || isNaN(x)) {
                    throw new Error('Input x must be a non-negative number');
                }
            
                // Handle x = 0 case: Si(0) = 0
                if (x === 0) return 0;
            
                // Numerical integration parameters
                const n = 1000; // Number of trapezoids
                const h = x / n; // Step size
            
                // Integrand function: sin(t) / t
                function integrand(t) {
                    // Handle t near 0: sin(t)/t ≈ 1 for small t
                    if (Math.abs(t) < 1e-10) {
                        return 1;
                    }
                    return Math.sin(t) / t;
                }
            
                // Trapezoidal rule
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    const t = i * h;
                    if (i === 0 || i === n) {
                        sum += integrand(t) / 2; // Endpoints get half weight
                    } else {
                        sum += integrand(t);
                    }
                }
                return sum * h;
            }
            
            function cin(x) {
                // Input validation: ensure x is a positive number
                if (typeof x !== 'number' || x < 0 || isNaN(x)) {
                    throw new Error('Input x must be a non-negative number');
                }
            
                // Handle x = 0 case: Cin(0) = 0
                if (x === 0) return 0;
            
                // Numerical integration parameters
                const n = 1000; // Number of trapezoids (higher for more accuracy)
                const h = x / n; // Step size
            
                // Integrand function: (1 - cos(t)) / t
                function integrand(t) {
                    // Handle t near 0 to avoid division by zero
                    if (Math.abs(t) < 1e-10) {
                        // Use Taylor approximation: (1 - cos(t))/t ≈ t/2 for small t
                        return t / 2;
                    }
                    return (1 - Math.cos(t)) / t;
                }
            
                // Trapezoidal rule
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    const t = i * h;
                    if (i === 0 || i === n) {
                        // Endpoints get half weight in trapezoidal rule
                        sum += integrand(t) / 2;
                    } else {
                        sum += integrand(t);
                    }
                }
            
                // Multiply by step size to get integral
                return sum * h;
            }

            function radiationResistance(frequency, antenna_length) {
                const wavelength = CC / frequency;
                const length_in_lambda = antenna_length / wavelength;
                const neta = 120.0 * Math.PI;
                const C = 0.5772;  // Eulers constant (see Balanis eq 4-68)
                let kl = 2.0 * Math.PI * length_in_lambda; // Check this!
                let Rr = 0.0;
                Rr += C + Math.log(kl);
                Rr -= ci(kl);
                Rr += 0.5 * Math.sin(kl) * (si(2*kl) - 2*si(kl));
                Rr += 0.5 * Math.cos(kl) * (C + Math.log(kl * 0.5) + ci(2 * kl) - 2 * ci(kl));
                Rr *= neta / (2 * Math.PI);
                return Rr;
            }

            function inductiveReactance(frequency, antenna_length) {
                const wavelength = CC / frequency;
                const length_in_lambda = antenna_length / wavelength;
                const neta = 120.0 * Math.PI;
                const C = 0.5772;   // Eulers constant (see Balanis eq 4-68)
                const a = 0.001;    // wire radius in lambda
                let kl = 2.0 * Math.PI * length_in_lambda; // Check this!
                let retval = 0.0;
                retval += 2 * si(kl);
                retval += Math.cos(kl) * (2*si(kl) - si(2 * kl));
                retval -= Math.sin(kl) * (2*ci(kl) - ci(2*kl)- ci(4.0 * Math.PI * a**2.0 / length_in_lambda));
                retval *= neta / (4 * Math.PI);
                return retval;
            }

            function calculateAll() {
                setGlobals();
                frequencies.forEach(freq => {
                    let total_admittance = math.complex(0,0);
                    Object.keys(dipole).forEach(key => {
                        // console.log(key, dipole[key]);
                        if(dipole[key]['enabled']) {
                            const len = dipole[key]['length'];
                            const rr = radiationResistance(freq * 1e6, len);
                            const xx = inductiveReactance(freq * 1e6, len);
                            dipole[key]['Rr'].push({x:freq, y:rr});
                            dipole[key]['Xm'].push({x:freq, y:xx});
                const wavelength = CC / (freq * 1e6);
                const length_in_lambda = len / wavelength;
                            const sin_kl_on_2_sqrd = 1.0 / (Math.sin(Math.PI * length_in_lambda)**2);
                            //const sin_kl_on_2_sqrd = 1.0 / (Math.sin(Math.PI * len * freq * 1e6 / CC)**2);
                            //const sin_kl_on_2_sqrd = 1.0 ;
                            let impedance = math.complex(rr * sin_kl_on_2_sqrd, xx * sin_kl_on_2_sqrd);
                            dipole[key]['Z'].push({x:freq, y:impedance.toPolar().r});
                            let admittance = impedance.inverse();
                            total_admittance = math.add(total_admittance, admittance);
                        }
                    });
                    const impedance = total_admittance.inverse();
                    //const impedance_polar = impedance.toPolar();
                    feedpoint_impedances.push({x:freq, y:impedance});
                    
                    // Now calculate the magnitude reflection coefficient gamma, then the SWR:
                    const Z0 = math.complex(50.0, 0.0);
                    const gamma_mag = math.divide(math.subtract(impedance, Z0), math.add(impedance, Z0)).toPolar().r;
                    const SWR = (1 + gamma_mag)/(1 - gamma_mag);
                    SWRs.push({x:freq, y:SWR});
                });
            }

            function getSWR() {
                var retval = [];
                SWRs.forEach(item => {
                    retval.push(item);
                })
                return retval;
            }

            function getImpedance() {
                var retval = [];
                feedpoint_impedances.forEach(item => {
                    retval.push({x:item.x, y:item.y.toPolar().r});
                });
                return retval;
            }

            function getFeedpointImpedanceReal() {
                var retval = [];
                feedpoint_impedances.forEach(item => {
                    retval.push({x:item.x, y:item.y.re});
                });
                return retval;
            }

            function getFeedpointImpedanceImag() {
                var retval = [];
                feedpoint_impedances.forEach(item => {
                    retval.push({x:item.x, y:item.y.im});
                });
                return retval;
            }

            function updateAll() {
                setGlobals();
                drawFrontDesign();
                drawSideDesign();
                updateFrequencies();
                calculateAll();
                myChart.data.datasets[0].data = getSWR();
                myChart.data.datasets[1].data = getImpedance();
                myChart.data.datasets[2].data = getFeedpointImpedanceReal();
                myChart.data.datasets[3].data = getFeedpointImpedanceImag();
                myChart.update();
                updateURL();
            }

            // Specify fonts for changing parameters controlled by the sliders:
            const normal_font = "bold 12px arial";
            const hidden_font = "italic 12px arial";
            const emphasis_font = "bold 14px arial";
            const emphasis_delay = 1000;
            
            const normal_width = 1;
            const emphasis_width = 3;
            
            var angle_timer_handler = 0;
            var angle_font = normal_font;
            var angle_thickness = normal_width;
            angle_slider.oninput = function() {
                if(angle_timer_handler == 0) {
                    angle_font = emphasis_font;
                    angle_thickness = emphasis_width;
                } else {
                    clearTimeout(angle_timer_handler);
                }
                angle_timer_handler = setTimeout(function(){
                    angle_font = normal_font;
                    angle_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    angle_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length1_timer_handler = 0;
            var length1_font = normal_font;
            var length1_thickness = normal_width;
            length1_slider.oninput = function() {
                if(length1_timer_handler == 0) {
                    length1_font = emphasis_font;
                    length1_thickness = emphasis_width;
                } else {
                    clearTimeout(length1_timer_handler);
                }
                length1_timer_handler = setTimeout(function(){
                    length1_font = normal_font;
                    length1_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length1_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length2_timer_handler = 0;
            var length2_font = normal_font;
            var length2_thickness = normal_width;
            length2_slider.oninput = function() {
                if(length2_timer_handler == 0) {
                    length2_font = emphasis_font;
                    length2_thickness = emphasis_width;
                } else {
                    clearTimeout(length2_timer_handler);
                }
                length2_timer_handler = setTimeout(function(){
                    length2_font = normal_font;
                    length2_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length2_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length3_timer_handler = 0;
            var length3_font = normal_font;
            var length3_thickness = normal_width;
            length3_slider.oninput = function() {
                if(length3_timer_handler == 0) {
                    length3_font = emphasis_font;
                    length3_thickness = emphasis_width;
                } else {
                    clearTimeout(length3_timer_handler);
                }
                length3_timer_handler = setTimeout(function(){
                    length3_font = normal_font;
                    length3_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length3_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length4_timer_handler = 0;
            var length4_font = normal_font;
            var length4_thickness = normal_width;
            length4_slider.oninput = function() {
                if(length4_timer_handler == 0) {
                    length4_font = emphasis_font;
                    length4_thickness = emphasis_width;
                } else {
                    clearTimeout(length4_timer_handler);
                }
                length4_timer_handler = setTimeout(function(){
                    length4_font = normal_font;
                    length4_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length4_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            var length5_timer_handler = 0;
            var length5_font = normal_font;
            var length5_thickness = normal_width;
            length5_slider.oninput = function() {
                if(length5_timer_handler == 0) {
                    length5_font = emphasis_font;
                    length5_thickness = emphasis_width;
                } else {
                    clearTimeout(length5_timer_handler);
                }
                length5_timer_handler = setTimeout(function(){
                    length5_font = normal_font;
                    length5_thickness = normal_width;
                    detail_level = 1;
                    updateAll();
                    length5_timer_handler = 0;
                }, emphasis_delay);
                detail_level = 0;
                updateAll();
            }

            window.onresize = function() {
                myChart.resize();
                //myChart.update();
                drawFrontDesign();
                drawSideDesign();
                // console.log("resize!");
            }

            window.onorientationchange = function() {
                //myChart.resize();
                //myChart.update();
                drawFrontDesign();
                drawSideDesign();
            }

            window.onbeforeprint = function() {
                console.log("onbeforeprint");
                //myChart.resize();
                drawFrontDesign();
                drawSideDesign();
            }

            function drawWire(ctx, x1, y1, x2, y2, wireRadius, fillColor) {
                var angle = math.atan2(y1 - y2, x1 - x2) - Math.PI * 0.5;
                ctx.beginPath();
                ctx.arc(x1, y1, wireRadius, angle, Math.PI+angle);
                ctx.arc(x2, y2, wireRadius, Math.PI+angle, angle);
                ctx.fillStyle = fillColor;
                ctx.fill();
            }

            function drawAntenna(ctx, vertex_x, vertex_y, length, angle_deg) {
                const gap = 10;
                ctx.save();
                ctx.font = normal_font;
                ctx.translate(vertex_x, vertex_y);
                
                // Draw junction box:
                ctx.beginPath();
                ctx.moveTo(-gap, -3*gap); 
                ctx.lineTo( gap, -3*gap);
                ctx.lineTo( gap, +3*gap);
                ctx.lineTo(-gap, +3*gap);
                ctx.lineTo(-gap, -3*gap); 
                ctx.stroke();
                fctx.textAlign = "center";
                ctx.fillText(180 - (2*angle_deg), 0, 3*gap+14);
                
                const cos_angle = Math.cos(angle_deg*Math.PI/180);
                const sin_angle = Math.sin(angle_deg*Math.PI/180);
                const d1_length = length * length1_slider.value / 22;
                const d2_length = length * length2_slider.value / 22;
                const d3_length = length * length3_slider.value / 22;
                const d4_length = length * length4_slider.value / 22;
                const d5_length = length * length5_slider.value / 22;
                
                // Draw right side:
                ctx.beginPath();
                ctx.moveTo(10,-2*gap); ctx.lineTo(10+d1_length*cos_angle, -2*gap+d1_length*sin_angle);
                ctx.moveTo(10,-1*gap); ctx.lineTo(10+d2_length*cos_angle, -1*gap+d2_length*sin_angle);
                ctx.moveTo(10, 0*gap); ctx.lineTo(10+d3_length*cos_angle,  0*gap+d3_length*sin_angle);
                ctx.moveTo(10, 1*gap); ctx.lineTo(10+d4_length*cos_angle,  1*gap+d4_length*sin_angle);
                ctx.moveTo(10, 2*gap); ctx.lineTo(10+d5_length*cos_angle,  2*gap+d5_length*sin_angle);
                ctx.stroke();
                
                // Draw left side:
                ctx.beginPath();
                ctx.moveTo(-10,-2*gap); ctx.lineTo(-10-d1_length*cos_angle, -2*gap+d1_length*sin_angle);
                ctx.moveTo(-10,-1*gap); ctx.lineTo(-10-d2_length*cos_angle, -1*gap+d2_length*sin_angle);
                ctx.moveTo(-10, 0*gap); ctx.lineTo(-10-d3_length*cos_angle,  0*gap+d3_length*sin_angle);
                ctx.moveTo(-10, 1*gap); ctx.lineTo(-10-d4_length*cos_angle,  1*gap+d4_length*sin_angle);
                ctx.moveTo(-10, 2*gap); ctx.lineTo(-10-d5_length*cos_angle,  2*gap+d5_length*sin_angle);
                ctx.stroke();
                /*
                ctx.textAlign = "center";
                const s = (100.0 * loop_diameter_slider.value) * 0.57735; // side length in cm
                if(units == "metric") {
                    ctx.fillText(s.toPrecision(3).toString() + " cm", 0, 0);
                } else {
                    ctx.fillText((s*0.03281).toPrecision(3).toString() + "\'", 0, 0);
                }
                */
                ctx.restore();
            }

            const afront_canvas = document.getElementById("antennaFront2D");
            const fctx = afront_canvas.getContext('2d');

            function drawFrontDesign() {
                const win_width  = document.getElementById("antenna-front-container").offsetWidth; 
                const win_height = document.getElementById("antenna-front-container").offsetHeight; 
                afront_canvas.width = win_width-2; 
                afront_canvas.height = win_height-2; 

                fctx.clearRect(0, 0, win_width, win_height);
                
                fctx.font = angle_font;
                fctx.textAlign = "left";
                if(angle_cb.checked) { fctx.font = angle_font; } else { fctx.font = hidden_font; }
                fctx.fillText(angle_slider.value + '\u00B0', 10, 15);
                fctx.font = normal_font;
                
                drawAntenna(fctx, afront_canvas.width*0.5, afront_canvas.height*0.3, 120, angle_slider.value);
                //drawWire(fctx, afront_canvas.width*0.5, 10, );
            }
            
            const aside_canvas = document.getElementById("antennaSide2D");
            const sctx = aside_canvas.getContext('2d');

            function drawSideDesign() {
                const win_width  = document.getElementById("antenna-side-container").offsetWidth; 
                const win_height = document.getElementById("antenna-side-container").offsetHeight; 
                aside_canvas.width = win_width-2; 
                aside_canvas.height = win_height-2; 
                sctx.clearRect(0, 0, win_width, win_height);
                
                const x_m = 100;
                const x_ft = 150;
                const y_offset = 25;
                const y_spacing = 15;
                const places = 2;
                const m_2_ft = 3.28083;
                
                sctx.textAlign = "center";
                sctx.font = emphasis_font;
                sctx.fillText('Dipole Lengths', 75, 20);
                
                sctx.textAlign = "right";
                if(length1_cb.checked) { sctx.font = length1_font; } else { sctx.font = hidden_font; }
                sctx.fillText((1.0 * length1_slider.value).toFixed(places) + ' m  < D1 >', x_m, y_offset + y_spacing);
                sctx.fillText((m_2_ft * length1_slider.value).toFixed(places) + ' ft', x_ft, y_offset + y_spacing);
                if(length2_cb.checked) { sctx.font = length2_font; } else { sctx.font = hidden_font; }
                sctx.fillText((1.0 * length2_slider.value).toFixed(places) + ' m  < D2 >', x_m, y_offset + 2*y_spacing);
                sctx.fillText((m_2_ft * length2_slider.value).toFixed(places) + ' ft', x_ft, y_offset + 2*y_spacing);
                if(length3_cb.checked) { sctx.font = length3_font; } else { sctx.font = hidden_font; }
                sctx.fillText((1.0 * length3_slider.value).toFixed(places) + ' m  < D3 >', x_m, y_offset + 3*y_spacing);
                sctx.fillText((m_2_ft * length3_slider.value).toFixed(places) + ' ft', x_ft, y_offset + 3*y_spacing);
                if(length4_cb.checked) { sctx.font = length4_font; } else { sctx.font = hidden_font; }
                sctx.fillText((1.0 * length4_slider.value).toFixed(places) + ' m  < D4 >', x_m, y_offset + 4*y_spacing);
                sctx.fillText((m_2_ft * length4_slider.value).toFixed(places) + ' ft', x_ft, y_offset + 4*y_spacing);
                if(length5_cb.checked) { sctx.font = length5_font; } else { sctx.font = hidden_font; }
                sctx.fillText((1.0 * length5_slider.value).toFixed(places) + ' m  < D5 >', x_m, y_offset + 5*y_spacing);
                sctx.fillText((m_2_ft * length5_slider.value).toFixed(places) + ' ft', x_ft, y_offset + 5*y_spacing);
                sctx.font = normal_font;
            }
            
            // Set the global variables, which are all determined by physical dimensions, and are thus frequency-independent:
            setGlobals();
            // Update the frequencies, now that we have the sliders available:
            updateFrequencies();
            calculateAll();
            drawFrontDesign();
            drawSideDesign();

            const chartCanvas = document.getElementById("chartCanvas");
            const chartCanvasContext = chartCanvas.getContext('2d');

            function getMetricPrefix(num) {
                if(num >= 1e9) return  {val: num*1e-9, pfx:'G'};
                if(num >= 1e6) return  {val: num*1e-6, pfx:'M'};
                if(num >= 1e3) return  {val: num*1e-3, pfx:'k'};
                if(num < 1e-12) return {val: num*1e15, pfx:'f'};
                if(num < 1e-9) return  {val: num*1e12, pfx:'p'};
                if(num < 1e-6) return  {val: num*1e9,  pfx:'n'};
                if(num < 1e-3) return  {val: num*1e6,  pfx:'\u03bc'};
                if(num < 1.0) return   {val: num*1e3,  pfx:'m'};
                return {val:num, pfx:' '};
            }
            
            function justifyText(pre, post) {
                var whitespace = 22 - pre.length - post.length;
                if(whitespace < 0) { whitespace = 0;}
                return pre + ' '.repeat(whitespace) + post;
            }
            
            var myChart = new Chart(chartCanvasContext, {
                type: 'line',
                data: {
                    datasets: [
                    {
                        label: 'VSWR',
                        fill: false,
                        borderColor: 'black',
                        backgroundColor: 'black',
                        data: getSWR(),
                        borderWidth: 1,
                        yAxisID: 'swrID',
                        tension: 0.3,
                    },
                    {
                        label: '|Zin|',
                        fill: false,
                        borderColor: 'blue',
                        backgroundColor: 'blue',
                        data: getImpedance(),
                        borderWidth: 1,
                        yAxisID: 'ohmsID',
                        tension: 0.3,
                    },
                    {
                        label: 'Rin',
                        hidden: true,
                        fill: false,
                        borderColor: 'blue',
                        backgroundColor: 'lightblue',
                        data: getFeedpointImpedanceReal(),
                        borderWidth: 1,
                        borderDash: [5,5],
                        yAxisID: 'ohmsID',
                        tension: 0.3,
                    },
                    {
                        label: 'Xin',
                        hidden: true,
                        fill: false,
                        borderColor: 'red',
                        backgroundColor: 'red',
                        data: getFeedpointImpedanceImag(),
                        borderWidth: 1,
                        yAxisID: 'xOhmsID',
                        tension: 0.3,
                    },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    elements: {
                        point: {
                            radius: 0,
                        },
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: 0.0,
                            max: 30.0,
                            position: 'bottom',
                            display: 'true',
                            title: {
                                display: true,
                                text: 'Frequency (MHz)',
                                color: 'black',
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                stepSize: 1.0,
                            }
                        },
                        'ohmsID' : {
                            type: 'linear',
                            display: 'auto',
                            title: {
                                display: true,
                                text: '\u03A9',
                                color: 'blue',
                                font: {
                                    weight : 'bold'
                                }
                            },
                            ticks: {
                                beginAtZero: true,
                            },
                            min: 0.0,
                            max: 500.0,
                            position: 'right',
                        },
                        'xOhmsID' : {
                            type: 'linear',
                            display: 'auto',
                            title: {
                                display: true,
                                text: 'j\u03A9',
                                color: 'red',
                                font: {
                                    weight : 'bold'
                                }
                            },
                            ticks: {
                                beginAtZero: true,
                            },
                            min: -250.0,
                            max: 250.0,
                            position: 'right',
                        },
                        'swrID' : {
                            type: 'linear',
                            display: 'auto',
                            title: {
                                display: true,
                                text: 'VSWR',
                                color: 'black',
                                font: {
                                    weight : 'bold'
                                }
                            },
                            ticks: {
                                beginAtZero: true,
                            },
                            min: 1.0,
                            max: 6.0,
                            position: 'left',
                        },
                    },
                    plugins: {
                        //showLines: true,
                        mode: 'nearest',
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            position: 'nearest',
                            bodyFont: {
                                family: 'monospace',
                            },
                            callbacks: {
                                title: function(context) {
                                    var value = context[0].parsed.x;
                                    var lut = [
                                    [0.1357, 0.1378,'2200'], 
                                    [0.472, 0.479, '600'], 
                                    [1.8, 1.875, '160'], 
                                    [3.5, 3.8, '80'], 
                                    [5.3, 5.4, '60'], 
                                    [7.0, 7.3, '40'], 
                                    [10.1, 10.15, '30'], 
                                    [14.0, 14.35, '20'], 
                                    [18.068, 18.168, '17'], 
                                    [21.0, 21.45, '15'], 
                                    [24.89, 24.99, '12'], 
                                    [26.965, 27.855, '11'], 
                                    [28.0, 29.7, '10'], 
                                    [50.0, 54.0, '6']];
                                    var label = '' + value.toFixed(3).toString() + ' MHz';
                                    for(let i = 0; i < lut.length; i++) {
                                        if((value >= lut[i][0]) && (value <= lut[i][1])) {
                                            label += ' (';
                                            label += lut[i][2] + ' m)';
                                            break;
                                        }
                                    }
                                    return label;
                                },
                                label: function(context) {
                                    var value = context.element.parsed.y;
                                    var label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if(label[1] == 'Z'){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("|Z|: ", num.val.toFixed(3).toString() + '   ' + num.pfx + '\u03A9');
                                    } else 
                                    if(label[0] == 'R'){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("Rin: ", num.val.toFixed(3).toString() + '   ' + num.pfx + '\u03A9');
                                    } else 
                                    if(label[0] == 'X'){
                                        //var num = getMetricPrefix(value);
                                        label = justifyText("Xin: ", value.toFixed(3).toString() + '   ' + 'j\u03A9');
                                    } else 
                                    if(label[0] == 'S'){
                                        var num = getMetricPrefix(value);
                                        label = justifyText("SWR: ", num.val.toPrecision(3).toString() + '    ' + num.pfx);
                                    } else {
                                        label += value.toFixed(3).toString();
                                    }
                                    return label;
                                }
                            }
                        },
                    }
                }
            });
        </script>
    </body>
</html>
